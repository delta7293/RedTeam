from typing import Optional, Any
import hashlib
import json

from pydantic import BaseModel


class ScoringLog(BaseModel):
    score: Optional[float] = None
    miner_input: Optional[dict] = None
    miner_output: Optional[dict] = None
    error: Optional[str] = None
    baseline_score: Optional[float] = None
    input_hash: Optional[str] = None

    def model_post_init(self, __context: Any):
        if self.miner_input:
            self.input_hash = hashlib.sha256(
                json.dumps(self.miner_input).encode("utf-8")
            ).hexdigest()
        else:
            self.input_hash = None

    def public_view(self) -> "ScoringLog":
        return ScoringLog(
            score=self.score,
            miner_input=None,
            miner_output=None,
            error=self.error,
            baseline_score=self.baseline_score,
            input_hash=None,
        )


class ComparisonLog(BaseModel):
    similarity_score: Optional[float] = None
    miner_input: Optional[dict] = None
    miner_output: Optional[dict] = None
    reference_output: Optional[dict] = None
    error: Optional[str] = None
    input_hash: Optional[str] = None

    reference_hotkey: Optional[str] = None
    reference_similarity_score: Optional[float] = None

    def model_post_init(self, __context: Any):
        if self.miner_input:
            self.input_hash = hashlib.sha256(
                json.dumps(self.miner_input).encode("utf-8")
            ).hexdigest()
        else:
            self.input_hash = None

    def public_view(self) -> "ComparisonLog":
        return ComparisonLog(
            similarity_score=self.similarity_score,
            miner_input=None,
            miner_output=None,
            reference_output=None,
            error=self.error,
            reference_hotkey=self.reference_hotkey,
            reference_similarity_score=self.reference_similarity_score,
        )


class MinerChallengeCommit(BaseModel):
    # Basic information
    miner_uid: Optional[int] = None
    miner_hotkey: Optional[str] = None
    challenge_name: Optional[str] = None
    docker_hub_id: Optional[str] = None
    commit_timestamp: Optional[float] = None
    encrypted_commit: Optional[str] = None
    key: Optional[str] = None
    commit: Optional[str] = None

    # Scoring logs with input generated by controller
    scoring_logs: list[ScoringLog] = []

    # Comparision logs, this dict map reference commit 's docker_hub_id to comparison log
    comparison_logs: dict[str, list[ComparisonLog]] = {}

    # Final score and penalty for this miner's commit
    scored_timestamp: Optional[float] = None
    score: Optional[float] = None
    penalty: Optional[float] = None

    # Accepted by having penalty less than threshold
    accepted: Optional[bool] = None

    def public_view(self) -> "MinerChallengeCommit":
        """Returns a new instance with sensitive fields (scoring logs, comparison logs) removed."""
        return MinerChallengeCommit(
            miner_uid=self.miner_uid,
            miner_hotkey=self.miner_hotkey,
            challenge_name=self.challenge_name,
            docker_hub_id=self.docker_hub_id,
            commit_timestamp=self.commit_timestamp,
            encrypted_commit=self.encrypted_commit,
            key=self.key,
            commit=self.commit,
            scoring_logs=[log.public_view() for log in self.scoring_logs],
            comparison_logs={
                ref_commit: [log.public_view() for log in logs]
                for ref_commit, logs in self.comparison_logs.items()
            },
            scored_timestamp=self.scored_timestamp,
            score=self.score,
            penalty=self.penalty,
            accepted=self.accepted,
        )

    def get_higest_comparison_score(self) -> float:
        """Get the minimum and maximum similarity score from all comparison logs."""
        if not self.comparison_logs:
            return 0.0

        all_scores = [
            log.similarity_score
            for logs in self.comparison_logs.values()
            for log in logs
            if log.similarity_score is not None
        ]
        return max(all_scores) if all_scores else 0.0

    def get_higest_scoring_score(self) -> float:
        """Get the maximum score from all scoring logs."""
        if not self.scoring_logs:
            return 0.0

        all_scores = [log.score for log in self.scoring_logs if log.score is not None]
        return max(all_scores) if all_scores else 0.0
